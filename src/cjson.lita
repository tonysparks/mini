@include("<cJSON.h>");
@cFile("src/cJSON.c");

@foreign
public enum JsonType {
    cJSON_Invalid = (0),
    cJSON_False  = (1 << 0),
    cJSON_True   = (1 << 1),
    cJSON_NULL   = (1 << 2),
    cJSON_Number = (1 << 3),
    cJSON_String = (1 << 4),
    cJSON_Array  = (1 << 5),
    cJSON_Object = (1 << 6),
    cJSON_Raw    = (1 << 7), /* raw json */

    cJSON_IsReference = 256,
    cJSON_StringIsConst = 512,
}

@foreign
public struct cJSON {
    next: cJSON*
    prev: cJSON*
    child: cJSON*
    type: JsonType

    valuestring: char*    
    valueint: i32
    valuedouble: f64;
    string: char*;
} 

@foreign public func cJSON_Version() : char const*;

/* Supply malloc, realloc and free functions to cJSON */
//@foreign public func cJSON_InitHooks(hooks: cJSON_Hooks);

/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */
/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */
@foreign public func cJSON_Parse(value: char const*) : cJSON*;
/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
//@foreign public func cJSON_ParseWithOpts
//CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);

/* Render a cJSON entity to text for transfer/storage. */
//@foreign public func cJSON_Print
//CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
/* Render a cJSON entity to text for transfer/storage without any formatting. */
//@foreign public func cJSON_PrintUnformatted
//CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
//@foreign public func cJSON_PrintBuffered
//CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
//@foreign public func cJSON_PrintPreallocated
//CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
/* Delete a cJSON entity and all subentities. */
//@foreign public func cJSON_Delete
//CJSON_PUBLIC(void) cJSON_Delete(cJSON *c);

/* Returns the number of items in an array (or object). */
//@foreign public func cJSON_GetArraySize
//CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
/* Retrieve item number "index" from array "array". Returns NULL if unsuccessful. */
//@foreign public func cJSON_GetArrayItem
//CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
/* Get item "string" from object. Case insensitive. */
//@foreign public func cJSON_GetObjectItem
//CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
//@foreign public func cJSON_GetObjectItemCaseSensitive
//CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
//@foreign public func cJSON_HasObjectItem
//CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
//@foreign public func cJSON_GetErrorPtr
//CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);

/* Check if the item is a string and return its valuestring */
//@foreign public func cJSON_GetStringValue
//CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item);

/* These functions check the type of an item */
/*@foreign public func cJSON_IsInvalid
CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
@foreign public func cJSON_IsFalse
CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
@foreign public func cJSON_IsTrue
CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
@foreign public func cJSON_IsBool
CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
@foreign public func cJSON_IsNull
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
@foreign public func cJSON_IsNumber
CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
@foreign public func cJSON_IsString
CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
@foreign public func cJSON_IsArray
CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
@foreign public func cJSON_IsObject
CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
@foreign public func cJSON_IsRaw
CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);
*/
/* These calls create a cJSON item of the appropriate type. */
/*@foreign public func cJSON_CreateNull
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
@foreign public func cJSON_CreateTrue
CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
@foreign public func cJSON_CreateFalse
CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
@foreign public func cJSON_CreateBool
CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
@foreign public func cJSON_CreateNumber
CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
@foreign public func cJSON_CreateString
CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);

@foreign public func cJSON_CreateRaw
CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);
@foreign public func cJSON_CreateArray
CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);
@foreign public func cJSON_CreateObject
CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);
*/

/* Create a string where valuestring references a string so
 * it will not be freed by cJSON_Delete */
//@foreign public func cJSON_CreateStringReference
//CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
/* Create an object/arrray that only references it's elements so
 * they will not be freed by cJSON_Delete */
//@foreign public func cJSON_CreateObjectReference
//CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
//@foreign public func cJSON_CreateArrayReference
//CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);

/* These utilities create an Array of count items. */
/*@foreign public func cJSON_CreateIntArray
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
@foreign public func cJSON_CreateFloatArray
CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
@foreign public func cJSON_CreateDoubleArray
CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
@foreign public func cJSON_CreateStringArray
CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count);
*/
/* Append item to the specified array/object. */
//@foreign public func cJSON_AddItemToArray
//CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item);
//@foreign public func cJSON_AddItemToObject
//CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.
 * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
 * writing to `item->string` */
//@foreign public func cJSON_AddItemToObjectCS
//CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
//@foreign public func cJSON_AddItemReferenceToArray
//CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
//@foreign public func cJSON_AddItemReferenceToObject
//CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);

/* Remove/Detatch items from Arrays/Objects. */
/*@foreign public func cJSON_DetachItemViaPointer
CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
@foreign public func cJSON_DetachItemFromArray
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);
@foreign public func cJSON_DeleteItemFromArray
CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
@foreign public func cJSON_DetachItemFromObject
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);
@foreign public func cJSON_DetachItemFromObjectCaseSensitive
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
@foreign public func cJSON_DeleteItemFromObject
CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
@foreign public func cJSON_DeleteItemFromObjectCaseSensitive
CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);
*/
/* Update array items */
//@foreign public func cJSON_InsertItemInArray
//CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
//@foreign public func cJSON_ReplaceItemViaPointer
//CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
//@foreign public func cJSON_ReplaceItemInArray
//CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
//@foreign public func cJSON_ReplaceItemInObject
//CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
//@foreign public func cJSON_ReplaceItemInObjectCaseSensitive
//CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);

/* Duplicate a cJSON item */
//@foreign public func cJSON_Duplicate
//CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
need to be released. With recurse!=0, it will duplicate any children connected to the item.
The item->next and ->prev pointers are always zero on return from Duplicate. */
/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
 * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
// @foreign public func cJSON_Compare
//CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);

@foreign public func cJSON_Minify(json: char*);


/* Helper functions for creating and adding items to an object at the same time.
 * They return the added item or NULL on failure. */
/*@foreign public func cJSON_AddNullToObject(object: const cJSON*, name: const char const*) : cJSON*;
@foreign public func cJSON_AddTrueToObject(object: const cJSON*, name: const char const*) : cJSON*;
@foreign public func cJSON_AddFalseToObject(object: const cJSON*, name: const char const*) : cJSON*;
@foreign public func cJSON_AddBoolToObject(object: const cJSON*, name: const char const*, boolean: const cJSON_bool) : cJSON*;
@foreign public func cJSON_AddNumberToObject(object: const cJSON*, name: const char const*, number: const double) : cJSON*;
@foreign public func cJSON_AddStringToObject(object: const cJSON*, name: const char const*, string: const char const*) : cJSON*;
@foreign public func cJSON_AddRawToObject(object: const cJSON*, name: const char const*, raw: const char const*) : cJSON*;
@foreign public func cJSON_AddObjectToObject(object: const cJSON*, name: const char const*) : cJSON*;
@foreign public func cJSON_AddArrayToObject(object: const cJSON*, name: const char const*) : cJSON*;
*/


/* When assigning an integer value, it needs to be propagated to valuedouble too. */
@foreign public func cJSON_SetIntValue(object: cJSON*, number: f64) : f64;
/* helper for the cJSON_SetNumberValue macro */
@foreign public func cJSON_SetNumberHelper(object: cJSON*, number: f64) : f64;
@foreign public func cJSON_SetNumberValue(object: cJSON*, number: f64) : f64;


/* Macro for iterating over an array or object */
//@foreign public func 
//#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)

/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */
@foreign public func cJSON_malloc(size: u64) : void*;
@foreign public func cJSON_free(object: void*);

