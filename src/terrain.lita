import "common"
import "mem"
import "raylib"
import "config"
import "game"
import "camera"
import "json"
import "io"
import "building"
import "gang"
import "entity"

enum TerrainFlag {
    FLIPPED_HORIZONTALLY = 0x80000000,
    FLIPPED_VERTICALLY   = 0x40000000,
    FLIPPED_DIAGONALLY   = 0x20000000,
}

struct Tile {
    region: Rectangle
    tex: Texture2D    
}

const MAX_TILESETS = 16
const MAX_LAYERS = 32
const MAX_WIDTH = 1024
const MAX_HEIGH = 1024
const MAX_LAYER_NAME = 64

public struct TileSet {
    tex: Texture2D
    firstId: i32
}



public enum LayerFlags {
    IS_COLLIDABLE = (1<<0),
}

public struct Layer {
    flags: i32
    name: [MAX_LAYER_NAME]char
    tiles: u32*
    numOfTiles: i32
}

public struct Terrain {
    alloc: Allocator const*
    
    width: i32
    height: i32
    tileWidth: i32
    tileHeight: i32

    worldBounds: Rectangle

    tileSets: [MAX_TILESETS]TileSet
    numOfTileSets: i32

    layers: [MAX_LAYERS]Layer
    numOfLayers: i32

    tileCache: Tile*
}

public func (terrain: Terrain*) init(rawdata: char const*,
                                     game: Game*,
                                     alloc: Allocator const* = null) {

    if(!alloc) {
        alloc = cAllocator
    }

    terrain.alloc = alloc
    
    var parser = Parser{}
    parser.init(alloc)
    defer parser.free()

    var node = parser.parseJson(rawdata)
    if(parser.hasError()) {
        log(LogLevel.FATAL, "ERROR: Config parsing error '%s'\n", parser.errorMsg)
    }

    var width = node.getInt("width")
    var height = node.getInt("height")

    var tileWidth = node.getInt("tilewidth")
    var tileHeight = node.getInt("tileheight")

    terrain.width = width; terrain.height = height; terrain.tileWidth = tileWidth; terrain.tileHeight = tileHeight;
    RectSet(&terrain.worldBounds, 0, 0, (width*tileWidth) as (i32), (height*tileHeight) as (i32))    

    const N = 128
    var buf: [N]char;

    var maxTiles = 0
    var tileSets = node.getArray("tilesets")
    if(tileSets) {
        for(var i = 0; i < MAX_TILESETS && i < tileSets.size(); i+=1) {            
            var entry = tileSets.at(i)
            if(!entry) {
                break;
            }

            var image = entry.getStr("image", "no_image_path")
            snprintf(buf, N, "../assets/images/%s", image)
            var tex = LoadTexture(buf);

            var firstid = entry.getInt("firstgid")
            
            var tileSet = &terrain.tileSets[i]
            tileSet.tex = tex;
            tileSet.firstId = firstid;
            terrain.numOfTileSets += 1

            var w = tex.width / tileWidth
            var h = tex.height / tileHeight
            maxTiles += (w * h)
        }
    }

    terrain.tileCache = terrain.alloc.alloc(sizeof(Tile) * maxTiles)
    var cacheIndex = 0
    for(var i = 0; i < terrain.numOfTileSets; i+=1) {
        var tileSet = &terrain.tileSets[i]
        var tex = tileSet.tex

        var tw = tex.width / tileWidth
        var th = tex.height / tileHeight
        for(var h = 0; h < tex.height; h+=tileHeight) {
            for(var w = 0; w < tex.width; w+=tileWidth) {
                terrain.tileCache[cacheIndex] = Tile {
                    .tex = tex,
                    .region = Rectangle {
                        .x = w,
                        .y = h,
                        .width = tileWidth,
                        .height = tileHeight,
                    }
                }

                cacheIndex += 1
            }   
        }
    }

    var layers = node.getArray("layers")
    if(layers) {
        var layerId = 0
        for(var i = 0; i < MAX_LAYERS && i < layers.size(); i+=1) {
            var entry = layers.at(i)
            if(!entry) {
                break;
            }

            var type = entry.getStr("type", "")
            if(strcmp(type, "objectgroup") == 0) {
                var objects = entry.getArray("objects")
                if(!objects) {
                    continue;
                }

                
                for(var o = 0; o < objects.size(); o += 1) {
                    var object = objects.at(o)
                    var objectType = object.getStr("type", "")
                    if(strcmp(objectType, "building") == 0) {
                        game.buildings[game.numOfBuildings] = Building {
                            //.name: object.getStr("name", "Unknown"),
                            .entity: Entity {
                                .type = EntityType.BUILDING,
                                .bounds: Rectangle{object.getInt("x", 0), 
                                                   object.getInt("y", 0), 
                                                   object.getInt("width", 0), 
                                                   object.getInt("height", 0)
                                },
                            },
                            .loyalty: object.getInt("loyalty", 0),
                            .activities: 0,
                            .affiliated: GameGetGang(object.getStr("affiliated", "")),
                        }
                        var b = &game.buildings[game.numOfBuildings]
                        object.getStrCopy("name", b.name, MAX_NAME)

                        game.numOfBuildings += 1
                    }
                }

            }
            else if(strcmp(type, "tilelayer") == 0) {
                var layer = &terrain.layers[layerId];
                layerId += 1

                var name = entry.getStr("name", "")
                strncpy(layer.name as (void*), name as (void*), MAX_LAYER_NAME)
                
                var props = entry.getArray("properties")
                if(props) {
                    for(var p = 0; p < props.size(); p += 1) {
                        var prop = props.at(p)

                        var name = prop.getStr("name", "")
                        if(strcmp(name, "isCollidable") == 0) {
                            var isCollidable = prop.getStr("value", "false")
                            if(isCollidable && (strcmp(isCollidable, "true") == 0)) {
                                layer.flags |= LayerFlags.IS_COLLIDABLE
                            }
                        }
                    }
                }

                layer.numOfTiles = (width * height)
                layer.tiles = alloc.alloc(sizeof(u32) * layer.numOfTiles);
                terrain.numOfLayers += 1
                
                var data = entry.getArray("data")
                if(data) {
                    for(var t = 0; t < layer.numOfTiles; t += 1) {
                        var tileId = data.at(t)
                        if(tileId) {
                            layer.tiles[t] = tileId.asLong()
                        }
                    }
                }
            }
        }
    }
}

public func (terrain: Terrain*) destroy() {
    // TODO
}

public func (terrain: Terrain*) rectCollides(rect: Rectangle*) : bool {
    if(!RectContainsRect(&terrain.worldBounds, rect)) {
        return true
    }
    
    
    var pixelX = 0;
    var pixelY = 0;

    var indexX = 0;
    var indexY = 0;
    
    var toIndexX = 0;
    var toIndexY = 0;
    
    // Current Tile offset (to pixels)
    var tileOffsetX = -(rect.x as (i32) % terrain.tileWidth);
    toIndexX        = (tileOffsetX + rect.x as (i32)) / terrain.tileWidth;

    // current tile y offset (to pixels)
    var tileOffsetY = -(rect.y as (i32) % terrain.tileHeight);
    toIndexY        = (tileOffsetY + rect.y as (i32)) / terrain.tileHeight;
    
        
    indexY = toIndexY;
    for (pixelY = tileOffsetY;
         pixelY < rect.height && indexY < terrain.height;) {

        pixelX = tileOffsetX;
        indexX = toIndexX;

        for (;pixelX < rect.width && indexX < terrain.width;) {
            
            if ( (indexY >= 0 && indexX >= 0) && (indexY < terrain.height && indexX < terrain.width) ) {
                for (var i = 0; i < terrain.numOfLayers; i+=1) {
                    var layer = terrain.layers[i]

                    if(layer.flags & LayerFlags.IS_COLLIDABLE) {
                        var index = (indexY * terrain.width) + indexX 
                        
                        var tileid = layer.tiles[index]
                        if(tileid != 0) {
                            return true;
                        }
                    }                        
                }
            }

            
            pixelX += terrain.tileWidth;
            indexX += 1;
        }

        pixelY += terrain.tileHeight; 
        indexY += 1;
    }
    
    return false;
}

public func (terrain: Terrain*) draw(camera: GameCamera*) {
    
    var rect = Rectangle {
        camera.camera.target.x,
        camera.camera.target.y,
        GetScreenWidth(),
        GetScreenHeight()
    }

    var pixelX = 0;
    var pixelY = 0;

    var indexX = 0;
    var indexY = 0;
    
    var toIndexX = 0;
    var toIndexY = 0;
    
    // Current Tile offset (to pixels)
    var tileOffsetX = -(rect.x as (i32) % terrain.tileWidth);
    toIndexX        = (tileOffsetX + rect.x as (i32)) / terrain.tileWidth;

    // current tile y offset (to pixels)
    var tileOffsetY = -(rect.y as (i32) % terrain.tileHeight);
    toIndexY        = (tileOffsetY + rect.y as (i32)) / terrain.tileHeight;
    
    toIndexX = MAX(toIndexX, 0)
    toIndexY = MAX(toIndexY, 0)

    indexY = toIndexY;
    for (pixelY = 0;
         indexY < terrain.height;) {

        pixelX = 0;
        indexX = toIndexX;

        for (;indexX < terrain.width;) {
            for (var i = 0; i < terrain.numOfLayers; i+=1) {
                var layer = &terrain.layers[i]
                
                var index = (indexY * terrain.width) + indexX 
                var tileId = layer.tiles[index]
                
                var flippedHorizontally = (tileId & TerrainFlag.FLIPPED_HORIZONTALLY) != 0;
                var flippedVertically = (tileId & TerrainFlag.FLIPPED_VERTICALLY) != 0; 
                var flippedDiagonally = (tileId & TerrainFlag.FLIPPED_DIAGONALLY) != 0;

                tileId &= ~(TerrainFlag.FLIPPED_HORIZONTALLY |
                            TerrainFlag.FLIPPED_VERTICALLY |
                            TerrainFlag.FLIPPED_DIAGONALLY);


                if(tileId < 1) {
                    continue;
                }

                var tile = &terrain.tileCache[tileId-1]
                var pos = Vec2 {
                    pixelX, pixelY
                }
                var region = Rectangle{tile.region.x, tile.region.y, tile.region.width, tile.region.height}

                if(flippedDiagonally) {
                    var rotation = 0f

                    var target = Rectangle{pixelX + tile.region.width/2f, pixelY + tile.region.height/2f, 
                                           tile.region.width, tile.region.height}

                    var origin = Vec2{tile.region.width/2f, tile.region.height/2f}

                    if(flippedHorizontally && flippedVertically) {
                        region.width *= -1
                        region.height *= -1 
                        rotation = -270f
                        DrawTexturePro(tile.tex, region, target, origin, rotation, WHITE)
                    }
                    else if(flippedHorizontally) {
                        rotation = -270f
                        
                        DrawTexturePro(tile.tex, region, target, origin, rotation, WHITE)
                    }
                    else if(flippedVertically) {
                        rotation = -90f                        
                        DrawTexturePro(tile.tex, region, target, origin, rotation, WHITE)
                    }
                    else {
                        region.height *= -1 
                        rotation = -270f
                        DrawTexturePro(tile.tex, region, target, origin, rotation, WHITE)
                    }
                }
                else {
                    if(flippedHorizontally) region.width  *= -1
                    if(flippedVertically)   region.height *= -1 

                    DrawTextureRec(tile.tex, region, pos, WHITE);                
                }
            }
            pixelX += terrain.tileWidth;
            indexX += 1;
        }

        pixelY += terrain.tileHeight; 
        indexY += 1;
    }

    /*
    for(var i = 0; i < terrain.numOfLayers; i+=1) {
        var layer = &terrain.layers[i]
        DrawLayer(terrain, layer, camera)
    }*/
}

// TODO: Profile and see if this is faster...
/*
func DrawLayer(terrain: Terrain*, layer: Layer*, camera: GameCamera*) {
    var rect = Rectangle {
        camera.pos.x,
        camera.pos.y,
        GetScreenWidth(),
        GetScreenHeight()
    }

    var pixelX = 0;
    var pixelY = 0;

    var indexX = 0;
    var indexY = 0;
    
    var toIndexX = 0;
    var toIndexY = 0;
    
    // Current Tile offset (to pixels)
    var tileOffsetX = -(rect.x as (i32) % terrain.tileWidth);
    toIndexX        = (tileOffsetX + rect.x as (i32)) / terrain.tileWidth;

    // current tile y offset (to pixels)
    var tileOffsetY = -(rect.y as (i32) % terrain.tileHeight);
    toIndexY        = (tileOffsetY + rect.y as (i32)) / terrain.tileHeight;
    
    toIndexX = MAX(toIndexX, 0)
    toIndexY = MAX(toIndexY, 0)

    indexY = toIndexY;
    for (pixelY = 0;
         indexY < terrain.height;) {

        pixelX = 0;
        indexX = toIndexX;

        for (;indexX < terrain.width;) {
            var index = (indexY * terrain.width) + indexX 
            var tileId = layer.tiles[index]
            if(!tileId) {
                continue;
            }

            var tile = &terrain.tileCache[tileId-1]
            var pos = Vec2 {
                pixelX, pixelY
            }

            DrawTextureRec(tile.tex, tile.region, pos, WHITE);
            
            pixelX += terrain.tileWidth;
            indexX += 1;
        }

        pixelY += terrain.tileHeight; 
        indexY += 1;
    }    
}


func DrawLayer(terrain: Terrain*, layer: Layer*, camera: Camera2D*) {
    var x = 0
    var y = 0
    
    const tileWidth = terrain.tileWidth
    const tileHeight = terrain.tileHeight
    const maxHeight = terrain.height * terrain.tileHeight
    const maxWidth = terrain.width * terrain.tileWidth

    for(var j = 0; j < layer.numOfTiles; j+=1) {
        var tileId = layer.tiles[j]        
        if(tileId > 0) {
            var tile = terrain.tileCache[tileId-1]
            var pos = Vec2 {
                x, y
            }
            DrawTextureRec(tile.tex, tile.region, pos, WHITE);
        }

        
        x += tileWidth
        if(x >= maxWidth) {
            y += tileHeight
            x = 0
        }
    }
}*/