import "common";
import "raylib" as ray;
import "io";

public typedef i32 as Keymods

public enum Keymod {
    KMOD_NONE   = 0,
    KMOD_LSHIFT = (1<<0),
    KMOD_RSHIFT = (1<<1),
    KMOD_LCTRL  = (1<<2),
    KMOD_RCTRL  = (1<<3),
    KMOD_LALT   = (1<<4),
    KMOD_RALT   = (1<<5),
    KMOD_LGUI   = (1<<6),
    KMOD_RGUI   = (1<<7),
    KMOD_NUM    = (1<<8),
    KMOD_CAPS   = (1<<9),
    KMOD_MODE   = (1<<10),
    KMOD_CTRL   = (Keymod.KMOD_LCTRL|Keymod.KMOD_RCTRL),
    KMOD_SHIFT  = (Keymod.KMOD_LSHIFT|Keymod.KMOD_RSHIFT),
    KMOD_ALT    = (Keymod.KMOD_LALT|Keymod.KMOD_RALT),
    KMOD_GUI    = (Keymod.KMOD_LGUI|Keymod.KMOD_RGUI),

    KMOD_RESERVED
}

public enum KeyType {
    PRESSED,
    RELEASED
}

public struct KeyEvent {
    type: KeyType
    keyCode: i32
    mod: Keymods
}

public typedef func(KeyEvent*) : void as OnKeyEvent;

public struct MouseEvent {
    type: i32
    button: i32
    pos: Vec2
    flags: i32
    wheelDir: i32
}

public typedef func(MouseEvent*) : void as OnMouseEvent;


struct Key {
    timePressed : Time
}

const MAX_LISTENERS = 32;
const MAX_KEYS = 348

struct InputSys {
    keyListeners: [MAX_LISTENERS]OnKeyEvent;
    mouseListeners: [MAX_LISTENERS]OnMouseEvent;

    numKeyListeners: i32
    numMouseListeners: i32

    mousePos: Vec2
    keys: [MAX_KEYS]Key
    isCaps: bool
    isInsert: bool
}

const inputSys = InputSys{}

public func InputSysInit() {

}

public func InputSysDestroy() {

}

public func InputSysUpdate(timeStep: TimeStep*) {
    const validKeyIndex = 39
    for(var i = validKeyIndex; i < MAX_KEYS; i+=1) {
        var key = &inputSys.keys[i]
        if(ray::IsKeyDown(i)) {
            if(key.timePressed == 0) {
                key.timePressed = timeStep.gameClock
                //printf("Key: %d, Time: %llu\n", i, key.timePressed)

                emitKeyEvent(key, i);
            }
        }
        else if(ray::IsKeyUp(i) && key.timePressed) {
            key.timePressed = 0
            //printf("KeyReleased: %d\n", i)

            emitKeyEvent(key, i);
        }
    }

    if(ray::IsKeyReleased(ray::KeyboardKey.KEY_CAPS_LOCK)) {
        inputSys.isCaps = !inputSys.isCaps
    }

    if(ray::IsKeyReleased(ray::KeyboardKey.KEY_INSERT)) {
        inputSys.isCaps = !inputSys.isInsert
    }
}

public func InputSysRegisterKeyboardHandler(onKey : OnKeyEvent) {
    if(inputSys.numKeyListeners + 1 > MAX_LISTENERS) {
        log(LogLevel.ERROR, "Unable to register Keyboard handler, as the number of registered handlers has exceeded the max: %d \n", MAX_LISTENERS);
        return;
    }

    inputSys.keyListeners[inputSys.numKeyListeners] = onKey;
    inputSys.numKeyListeners += 1
}

public func InputSysRegisterMouseHandler(onMouse : OnMouseEvent) {
    
}

func emitKeyEvent(key : Key*, keyCode: i32) {
    var mod : Keymods = 0
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_LEFT_SHIFT)) {
        mod |= Keymod.KMOD_LSHIFT
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_RIGHT_SHIFT)) {
        mod |= Keymod.KMOD_RSHIFT
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_LEFT_CONTROL)) {
        mod |= Keymod.KMOD_LCTRL
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_RIGHT_CONTROL)) {
        mod |= Keymod.KMOD_RCTRL
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_LEFT_ALT)) {
        mod |= Keymod.KMOD_LALT
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_RIGHT_ALT)) {
        mod |= Keymod.KMOD_RALT
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_KB_MENU)) {
        mod |= Keymod.KMOD_LGUI
        mod |= Keymod.KMOD_RGUI
    }
    if(ray::IsKeyDown(ray::KeyboardKey.KEY_KB_MENU)) {
        mod |= Keymod.KMOD_LGUI
        mod |= Keymod.KMOD_RGUI
    }

    if(inputSys.isCaps) {
        mod |= Keymod.KMOD_CAPS
    }

    if(inputSys.isInsert) {
        mod |= Keymod.KMOD_MODE
    }

    var type = KeyType.RELEASED
    if(key.timePressed > 0) {
        type = KeyType.PRESSED;
    }

    var event = KeyEvent {
        .type: type,
        .keyCode: keyCode,
        .mod: mod,
    }

    for(var i = 0; i < inputSys.numKeyListeners; i+=1) {
        inputSys.keyListeners[i](&event);
    }
}