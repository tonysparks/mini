import "common"
import "raylib"
import "array"
import "model"
import "animation"

public const MAX_NAME = 32

public enum EntityType {
    GANG_MEMBER,
    BYSTANDERD,
    BUILDING,
    CAR,
}

public struct Entity {
    type: EntityType
    bounds: Rectangle
}


/**
    Character attributes to
    draw and orientate them
*/    
public struct Character {
    entity: using Entity

    state: State
    dir: Direction
    texture: Texture2D
    model: [State.MAX][Direction.MAX]StateModel
}

public enum State {
    IDLE,
    WALKING,
    // others

    MAX
}

public enum Direction {
    NORTH,
    EAST,
    SOUTH,
    WEST,

    MAX
}

public struct GangMember {
    name: [MAX_NAME]char
    loyalty: i32
    affiliated: Gang*
    weapon: Weapon

    character: using Character
}

public typedef i64 as USD

public struct Gang {
    name: [MAX_NAME]char
    members: Array<GangMember*>
    cash: USD
}

public struct WeaponStat {
    damage: i32
    accuracy: i32  // odds of landing damage
}

public const WeaponStats = [WeaponType.MAX]WeaponStat {
    [WeaponType.FISTS] = WeaponStat {10, 30},
    [WeaponType.KNIVE] = WeaponStat {40, 20},
    [WeaponType.PISTOL] = WeaponStat {45, 60},
    [WeaponType.AUTOMATIC] = WeaponStat {70, 90},
}

// How expansive do we want arms to be; at least
// define grades (Knives, Pistols, Automatics)
public enum WeaponType {
    FISTS,
    KNIVE,
    PISTOL,
    AUTOMATIC,

    MAX
}

public struct Weapon {
    type: WeaponType
    cost: USD
    stat: WeaponStat
}


/*
=========================================
Gang Member
=========================================
*/

public func (g: GangMember*) init(pos: Vec2/*config: JsonNode* */) {
    // TODO: Create Asset Manager
    var tex = LoadTexture("../assets/images/members.png");
    var COLS = 12
    var ROWS = 8

    g.type = EntityType.GANG_MEMBER
    g.bounds.x = pos.x
    g.bounds.y = pos.y
    g.bounds.width = tex.width / COLS
    g.bounds.height = tex.height / ROWS

    g.loyalty = 0
    g.weapon.type = WeaponType.FISTS
    g.weapon.cost = 0
    g.weapon.stat = WeaponStats[WeaponType.FISTS]

    g.texture = tex
    g.state = State.IDLE
    g.dir = Direction.SOUTH

    const frameTime = 30_i64;

    var indexX = 0
    var indexY = 0

    // IDLE/SOUTH
    {
        var m = &g.model[State.IDLE][Direction.SOUTH]
        m.init(frameTime, 1)        

        m.sprites[0] = Sprite {
            .tex = tex,
            .region = Rectangle {
                .x = indexX + g.bounds.width * 1,
                .y = indexY + g.bounds.height * 0,
                .width = g.bounds.width,
                .height = g.bounds.width
            }
        }
    }
    // IDLE/EAST
    {
        var m = &g.model[State.IDLE][Direction.EAST]
        m.init(frameTime, 1)        

        m.sprites[0] = Sprite {
            .tex = tex,
            .region = Rectangle {
                .x = indexX + g.bounds.width * 1,
                .y = indexY + g.bounds.height * 2,
                .width = g.bounds.width,
                .height = g.bounds.width
            }
        }
    }    
    // IDLE/WEST
    {
        var m = &g.model[State.IDLE][Direction.WEST]
        m.init(frameTime, 1)        

        m.sprites[0] = Sprite {
            .tex = tex,
            .region = Rectangle {
                .x = indexX + g.bounds.width * 1,
                .y = indexY + g.bounds.height * 1,
                .width = g.bounds.width,
                .height = g.bounds.width
            }
        }
    }        
    // IDLE/NORTH
    {
        var m = &g.model[State.IDLE][Direction.NORTH]
        m.init(frameTime, 1)        

        m.sprites[0] = Sprite {
            .tex = tex,
            .region = Rectangle {
                .x = indexX + g.bounds.width * 1,
                .y = indexY + g.bounds.height * 3,
                .width = g.bounds.width,
                .height = g.bounds.width
            }
        }
    }        
}

public func (g: GangMember*) destroy() {
}

public func (g: GangMember*) update(timeStep: TimeStep*) {
    var m = &g.model[g.state][g.dir]
    var anim = &m.anim

    animationUpdate(anim, timeStep)
}

public func (g: GangMember*) draw() {
    var m = &g.model[g.state][g.dir]
    var anim = &m.anim

    if(anim.numberOfFrames > 0) {
        var frame = animationCurrentFrame(anim)
        
        var r = m.sprites[frame].region

        var pos = Vec2{g.bounds.x, g.bounds.y}
        DrawTextureRec(g.texture, r, pos, WHITE);
    }    
}


/*
=========================================
Gang
=========================================
*/

public func (g: Gang*) init(name: char const*) {
    strncpy(g.name, name, MAX_NAME)
    g.members.init(16)

    g.cash = 1_000 // some seed money's
}

public func (g: Gang*) addMember(member: GangMember*) {
    g.members.add(member)
    member.affiliated = g
}

public func (g: Gang*) destroy() {
    for(var i = 0; i < g.members.size(); i+=1) {
        var m = g.members.get(i)
        m.destroy()

        // TODO: free m
    }
    g.members.free()
}

public func (g: Gang*) update(timeStep: TimeStep*) {
    for(var i = 0; i < g.members.size(); i+=1) {
        var m = g.members.get(i)
        m.update(timeStep)
    }
}

public func (g: Gang*) draw() {
    for(var i = 0; i < g.members.size(); i+=1) {
        var m = g.members.get(i)
        m.draw()
    }
}